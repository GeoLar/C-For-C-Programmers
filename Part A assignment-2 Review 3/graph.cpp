#include "graph.h"
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>

using namespace std;

graph::graph(uint8 size)
{
	vector<int32> row;

	for(uint8 j=0;j<size;j++)
	{
		row.push_back(INFINITY_VALUE);
	}
	
	for(uint8 i=0;i<size;i++)
	{	
		graph_matrix.push_back(row);
	}
	
	for(uint8 i=0;i<size;i++)
	{
		for(uint8 j=0;j<size;j++)
		{
			if(i==j)
			{
				graph_matrix[i][j] = 0;
			}
		}
	}
	
	srand(time(NULL));
}

/**************************************************************************************************/	
/**************************************************************************************************/	

void graph::print()
{
	for(uint8 i=0;i<graph_matrix.size();i++)
	{
		for(uint8 j=0;j<graph_matrix.size();j++)
		{
			cout<< graph_matrix[i][j] << "\t";
		}
		cout << endl;
	}

}

/**************************************************************************************************/	
/**************************************************************************************************/	

uint32 graph::V(void)
{
	return graph_matrix.size();
}

/**************************************************************************************************/	
/**************************************************************************************************/	

uint32 graph::E(void)
{
	return 0;
}

/**************************************************************************************************/	
/**************************************************************************************************/	

bool graph::adjacent(uint32 v1, uint32 v2)
{
	return graph_matrix[v1][v2] == -1 ? false:true;
}
/**************************************************************************************************/	
/**************************************************************************************************/	

vector<int32> graph::neighbors(uint32 v)
{
	vector<int32> neighbors_list;
	for(uint32 i=0;i<graph_matrix.size();i++)
	{
		if(graph_matrix[v][i] != 0)
		{
			neighbors_list.push_back(i);
		}
	}
	return neighbors_list;
}
/**************************************************************************************************/	
/**************************************************************************************************/	

void graph::add_edge (uint32 v1, uint32 v2)
{
	/*Do nothing, Using Matrix implementation all nodes are already there*/
}

/**************************************************************************************************/	
/**************************************************************************************************/	

void graph::delete_edge (uint32 v1, uint32 v2)
{
	/*Do nothing, Using Matrix implementation nodes can't be deleted.*/
}

/**************************************************************************************************/	
/**************************************************************************************************/	

int32 graph::get_edge_value(uint32 v1, uint32 v2)
{
	return graph_matrix[v1][v2];
}
/**************************************************************************************************/	
/**************************************************************************************************/	
	
void graph::set_edge_value(uint32 v1, uint32 v2, int32 value)
{
	/*Graph is bi-directional, symmetric matrix*/
	graph_matrix[v1][v2] = value;
	graph_matrix[v2][v1] = value;
}


/**************************************************************************************************/	
/**************************************************************************************************/	

void graph::generate(uint32 density, uint32 d1, uint32 d2)
{
	for(uint8 i=0;i<graph_matrix.size();i++)
	{
		for(uint8 j=0;j<i;j++)
		{
			if((rand()%100)<density)
			{
				set_edge_value(i, j, ((rand()%(d2-d1)) + d1));
			}
		}
	}
}